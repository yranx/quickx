1.Mybatis-Plus 搭建与使用入门
https://www.jb51.net/article/141573.htm
Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。

MybatisPlusConfig.java  MyMetaObjectHandler.java    GeneratorServiceEntity.java

2.SpringBoot+Redis实现token鉴权
https://www.imooc.com/article/49750
  用户登录成功后后台会返回一个token给调用者，同时我们自定义了@AuthToken注解，被该注解标注的api进行请求的时候都需要进行token效验，
  效验通过才可以正常访问，实现接口级的鉴权控制。同时token具有生命周期，在用户持续一段时间不进行操作的话，token则会过期，
  用户一直操作的话，则不会过期。

  创建数据结构：

  SET FOREIGN_KEY_CHECKS=0;

  -- ----------------------------
  -- Table structure for t_sys_user
  -- ----------------------------
  DROP TABLE IF EXISTS `t_sys_user`;
  CREATE TABLE `t_sys_user` (
    `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
    `username` varchar(30) DEFAULT NULL COMMENT '用户名',
    `password` varchar(30) DEFAULT NULL COMMENT '密码',
    `created_at` datetime DEFAULT NULL COMMENT '创建时间',
    `updated_at` datetime DEFAULT NULL COMMENT '更新时间',
    `del_flag` tinyint(1) DEFAULT NULL COMMENT '删除标识 0:未删除 1:已删除',
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;

  流程分析
  1).客户端登录，输入用户名和密码，后台进行验证，如果验证失败则返回登录失败的提示。
  如果验证成功，则生成token然后将username和token双向绑定(可以根据username取出token也可以根据token取出username)存入redis,
  同时使用token+username作为key把当前时间戳也存入redis。并且给它们都设置过期时间。
  2)每次请求都会走拦截器，如果该接口标注了@AuthToken注解，则要检查http header中的Authorization字段，获取token，
  然后由于token与username双向绑定，我们可以通过获取的token来尝试从redis中获取username,如果可以获取则说明token正确，反之，说明错误，返回鉴权失败。
  3)token可以根据用户使用的情况来动态的调整自己过期时间。我们在生成token的同时也往redis里面存入了创建token时的时间戳，
  每次请求被拦截器拦截token 验证成功之后，将当前时间与存在redis里面的token生成时刻的时间戳进行比较，
  当当前时间的距离创建时间快要到达设置的redis过期时间的话，就重新设置token过期时间，将过期时间延长。
  如果用户在设置的redis过期时间的时间长度内没有进行任何操作（没有发请求），则token会在redis中过期。

  ConstantUtil Md5TokenGenerator TokenGenerator AuthToken AuthorizationInterceptor  WebAppConfiguration  UserLoginController

3.网络安全通信---AES+BASE64
https://www.imooc.com/article/49811
https://www.cnblogs.com/hailiang/archive/2012/02/29/2373154.html
    网络层封装的一套加密、解密，编码、解码的规则
    身份校验--MD5算法
        no.1 身份校验：校验访问接口的用户合法性，就是过滤掉那些通过脚本或者其他非正常app发起的访问请求
        no.2 MD5算法： MD5算法可以对一串输入生成一串唯一的不可逆的128bit的0和1的二进制串信息。
                       通常 app 都会在发起请求前根据自己公司所定义的规则做一次 MD5 计算，作为 token 发送给服务端进行校验。
                       MD5 有两个特性：唯一性和不可逆性。
        no.3 16位和32位的MD5值:  md5计算工具 http://www.cmd5.com/
                       MD5计算后输出是 128 bit 的 0 和 1 二进制串，1个十六进制是 4 个 bit，128 / 4 = 32，所以常说的 32 位的 MD5 指的是用十六进制来表示的输出串。
                       那么，为什么还会有 16 位的 MD 值？其实也就是嫌 32 位的数据太长了，所以去掉开头 8 位，末尾 8 位，截取中间的 16 位来作为 MD5 的输出值。
                       所以，MD5 算法的输出只有一种：128 bit 的二进制串，而通常结果都用十六进制表示而已。
        no.4 MD5的应用：数字签名、身份校验、完整性（一致性）校验
                        【app 持有一串密钥，这串密钥服务端也持有，除此外别人都不知道，因此 app 就可以跟服务端协商，
                         两边统一下交互的时候都有哪些数据是需要加入 MD5 计算的，以怎样的规则拼接进行 MD5 运算的，
                         这样一旦这些数据被三方攻击者篡改了，也能检查出来。
                         也就是说，密钥和拼接规则都是关键点，不可以泄漏出去。】
    敏感数据加密 -- AES + BASE64
        UTF-8 + AES + BASE64
            no.1 UTF-8 和 BASE64 都属于编解码，AES 属于对称加密算法。
            no.2 信息其实本质上是由二进制串组成，通过各种不同的编码格式，来将这段二进制串信息解析成具体的数据
            AES 属于对称加密算法，对称的意思是说，加密方和解密方用的是同一串密钥。
            信息经过加密后会变成一串毫无规律的二进制串，此时再选择一种编码方式来展示，通常是 BASE64 格式的编码。
            no.3 BASE64 编码是将所有信息都编码成只用大小写字母、0-9数字以及 + 和 / 64个字符表示，所有称作 BASE64。
            no.4 需要注意的是，因为 AES 加解密时输入和输出都是二进制串的信息，因此，在发送时需先将明文通过 UTF-8 解码成二进制串，然后进行加密，
            再对这串二进制密文通过 BASE64 编程成密文串发送给接收方。

        AES 加解密模式分很多种，首先，它有三种密钥形式，分别是 128 bit，192 bit，256 bit
        AES 还分四种模式的加解密算法：ECB，CBC，CFB，OFB
        最后一点，使用 CBC 模式进行加密时，是对明文串进行分组加密的，每组的大小都一样，因此在分组时就有可能会存在最后一组的数量不够的情况，那么这时就需要进行填充，
        而这个填充的概念就是 PKCS5Padding 和 PKCS7Padding 两种。
        这两种的填充规则都一样，区别只在于分组时规定的每组的大小。在PKCS5Padding中，明确定义 Block 的大小是 8 位，
        而在 PKCS7Padding 定义中，对于块的大小是不确定的，可以在 1-255 之间。

4.springboot使用WebJars结合前端
    引入webjars，以jar包的形式加入项目
    no.1 pom.xml中引入 <!-- 引用bootstrap -->
              		<dependency>
              			<groupId>org.webjars</groupId>
              			<artifactId>bootstrap</artifactId>
              			<version>3.3.7-1</version>
              		</dependency>

              		<!-- 引用jquery -->
              		<dependency>
              			<groupId>org.webjars</groupId>
              			<artifactId>jquery</artifactId>
              			<version>3.1.1</version>
              		</dependency>
    no.2 在src/main/resources/static文件下新建index.html,引用

5.SpringBoot的国际化使用
https://www.dalaoyang.cn/article/10
    no.1加入了nekohtml去掉html严格校验
    <!--去除html严格校验-->
		<dependency>
			<groupId>net.sourceforge.nekohtml</groupId>
			<artifactId>nekohtml</artifactId>
			<version>1.9.15</version>
		</dependency>
	no.2配置
        ##去除thymeleaf的html严格校验
        spring.thymeleaf.mode=LEGACYHTML5
    no.3 配置文件：在resources里面新建messages.properties（默认配置），messages_en_US.properties（英文），messages_zh_CN.properties（中文）
    no.4 在templates下新建chinaEng.html
    no.5 创建国际化配置文件，I18Config.java   IndexController.java--hello

6.邮件
    no.1 pom.xml
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-mail</artifactId>
            </dependency>
    no.2 配置文件
    no.3 MailController.java

7.几个数据源配置啥的以后用到再去了解
https://www.dalaoyang.cn/article/11
https://www.dalaoyang.cn/article/25
https://www.dalaoyang.cn/article/26
https://www.dalaoyang.cn/article/53

8.使用Actuator监控
(还有admin监控，用到再了解https://www.dalaoyang.cn/article/33)
https://www.dalaoyang.cn/article/27
    对应用自身监控，以及对应用系统配置查看等功能
    no.1 pom.xml
    <dependency>
    			<groupId>org.springframework.boot</groupId>
    			<artifactId>spring-boot-starter-actuator</artifactId>
    		</dependency>
    no.2 配置
    info.name=ranx
    info.server.port=${server.port}



10.Redis
    (1)NoSql出现的需求场景：高并发读写、海量数据的高效率存储和访问、高可扩展性和高可用性

11.rabbitMQ
博客
https://www.cnblogs.com/LipeiNet/category/896408.html
官方git
https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/java
